---
layout: layouts/secret
title: Draw
---
<div class="flex flex-1 flex-col lg:p-2">
  <canvas class="flex-1 border-b lg:aspect-video lg:h-auto lg:flex-none lg:border"></canvas>
  <div class="flex items-center justify-between space-x-4 p-2 lg:px-0">
    <button
      class="border border-gray-400 bg-gray-100 px-2 py-1"
      data-ref="saveButton"
    >
      Save
    </button>

    <button
      class="border border-red-400 bg-red-100 px-2 py-1"
      data-ref="clearButton"
    >
      Clear
    </button>
  </div>
</div>

<script>
  function useInput(el) {
    let lastMouseX = 0;
    let lastMouseY = 0;
    let mouseX = 0;
    let mouseY = 0;

    let mousePressed = false;

    const updateMousePosition = (x, y) => {
      const bounds = el.getBoundingClientRect();

      lastMouseX = mouseX;
      lastMouseY = mouseY;

      mouseX = Math.floor(x - bounds.left);
      mouseY = Math.floor(y - bounds.top);
    };

    document.addEventListener('mousedown', (e) => {
      if (e.button === 2) {
        return;
      }

      mousePressed = true;
    });
    document.addEventListener('mouseup', (e) => {
      mousePressed = false;
    });
    document.addEventListener('mousemove', (e) => {
      updateMousePosition(e.clientX, e.clientY);
    });

    document.addEventListener('touchstart', (e) => {
      updateMousePosition(e.clientX, e.clientY);
      mousePressed = true;
    });
    document.addEventListener('touchend', (e) => {
      mousePressed = false;
    });
    document.addEventListener('touchcancel', (e) => {
      mousePressed = false;
    });
    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      updateMousePosition(touch.clientX, touch.clientY);
    });

    return {
      get lastMouseX() {
        return lastMouseX;
      },
      get lastMouseY() {
        return lastMouseY;
      },
      get mouseX() {
        return mouseX;
      },
      get mouseY() {
        return mouseY;
      },
      get mousePressed() {
        return mousePressed;
      },
    };
  }

  /** @param {HTMLCanvasElement} canvas */
  function setUpDraw(canvas) {
    const dpr = window.devicePixelRatio;

    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;

    canvas.style.width = `${canvas.clientWidth}px`;
    canvas.style.height = `${canvas.clientHeight}px`;

    const input = useInput(canvas);

    const saveButton = document.querySelector('[data-ref="saveButton"]');
    saveButton.addEventListener('click', (e) => {
      canvas.toBlob((blob) => {
        /** @type HTMLAnchorElement */
        const downloadAnchor = document.createElement('a');
        downloadAnchor.href = URL.createObjectURL(blob);
        downloadAnchor.download = 'drawing.png';

        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
      });
    });

    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext('2d');

    ctx.scale(dpr, dpr);

    const clearButton = document.querySelector('[data-ref="clearButton"]');
    clearButton.addEventListener('click', (e) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    let brushSize = 10;

    const drawLine = (fromX, fromY, toX, toY) => {
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.lineCap = 'round';
      ctx.lineWidth = brushSize;
      ctx.stroke();
    };

    const tick = () => {
      if (input.mousePressed) {
        drawLine(input.lastMouseX, input.lastMouseY, input.mouseX, input.mouseY);
      }

      window.requestAnimationFrame(() => tick());
    };

    tick();
  }

  setUpDraw(document.querySelector('canvas'));
</script>
